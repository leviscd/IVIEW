<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPVIEW - TV ao Vivo (Smart TV Interface)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'ipview-dark': '#0F071A', // Cor primária do fundo
                        'ipview-violet': '#6D28D9', // Violeta primário
                        'ipview-purple': '#9333EA', // Púrpura secundário
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* 4. Estilo de Foco (Zoom e Glow) */
        :root {
            --color-focus-glow: 0 0 15px rgba(109, 40, 217, 0.8), 0 0 30px rgba(147, 51, 234, 0.6);
        }
        .focusable {
            transition: all 0.25s;
            outline: none; /* Remove o outline padrão */
        }
        .focused {
            transform: scale(1.06);
            box-shadow: var(--color-focus-glow);
            z-index: 10; /* Garante que fique acima de outros elementos não focados */
            border-color: #9333EA !important; /* Borda púrpura para cards/buttons */
        }

        /* 3. Efeitos de Fundo Abstrato (Micro-animação/Pulsação) */
        @keyframes subtle-move {
            0% { transform: translate(0, 0) scale(1.0); opacity: 0.6; }
            50% { transform: translate(5px, 5px) scale(1.05); opacity: 0.7; }
            100% { transform: translate(0, 0) scale(1.0); opacity: 0.6; }
        }
        .bg-shapes {
            background-image: radial-gradient(circle at 10% 20%, rgba(109, 40, 217, 0.2) 0%, transparent 50%),
                              radial-gradient(circle at 80% 90%, rgba(147, 51, 234, 0.3) 0%, transparent 50%);
            animation: subtle-move 20s infinite alternate ease-in-out;
        }

        /* 3. Gradiente para o Título (IPVIEW) */
        .ipview-gradient-text {
            background-image: linear-gradient(to right, #6D28D9, #9333EA);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* 6. Indicador de Status HLS (Invisível por padrão) */
        #lag-indicator {
            transition: opacity 0.3s, background-color 0.3s;
            opacity: 0;
        }
    </style>
</head>
<body class="bg-ipview-dark text-white font-sans min-h-screen" onkeydown="handleKeyDown(event)">

    <div id="app-container" class="min-h-screen">
        </div>

    <video id="video-player" class="hidden fixed top-0 left-0 w-full h-full object-cover" preload="auto" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.0/dist/hls.min.js"></script>

    <script>
        // 2. DADOS DE CANAIS E LINKS (OBRIGATÓRIO)
        const CHANNEL_DATA = {
            "esportes": [
                { "nome": "Premiere 1", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/d485d118d525ae4326aa31371f5dfcef/premiere.m3u8" },
                { "nome": "Premiere 2", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/aa1f6257eeb308e3e6677bae5fb7f1c8/premiere2.m3u8" }
            ],
            "noticias": [
                { "nome": "Record News", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/3728ae10c1a4f5b4a394d9771ec12db2/record.m3u8" }
            ],
            "infantil": [
                { "nome": "Cartoon Network", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/f67e159151a581847c31a461034c795a/cartoonnetwork.m3u8" },
                { "nome": "Nickelodeon", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/528246d1903b4743bca33088eedc800f/nickelodeon.m3u8" }
            ],
            "filmes_e_series": [
                { "nome": "Telecine Premium", "url": "https://placehold.co/400x225/ba55d3/ffffff?text=Telecine" },
                { "nome": "HBO HD", "url": "https://placehold.co/400x225/4b0082/ffffff?text=HBO" }
            ],
            "variedades": [
                { "nome": "Multishow", "url": "https://placehold.co/400x225/daa520/000000?text=Multi" },
                { "nome": "GNT", "url": "https://placehold.co/400x225/808080/ffffff?text=GNT" }
            ]
        };

        // Estado Global
        let currentView = 'home';
        let currentCategory = '';
        let currentChannelName = '';
        let focusedIndex = 0;
        let hls = null;
        let controlsTimer = null;
        let viewHistory = ['home']; // Para o botão Escape/Backspace

        // -----------------------------------------------------------
        // 7. FUNÇÃO DE NAVEGAÇÃO CENTRAL
        // -----------------------------------------------------------
        function Maps(viewName, data = null) {
            const container = document.getElementById('app-container');
            container.innerHTML = ''; // Limpa o container anterior
            currentView = viewName;
            
            // Gerencia o histórico de views (ignora se for o Player)
            if (viewName !== 'player') {
                // Adiciona ao histórico, mas evita duplicatas consecutivas (ex: Categories -> Categories)
                if (viewHistory[viewHistory.length - 1] !== viewName) {
                    viewHistory.push(viewName);
                } else if (viewName === 'channels' && viewHistory[viewHistory.length - 1] === 'channels') {
                    // Permite manter o histórico se a categoria mudou (não é o caso aqui, mas boa prática)
                    viewHistory[viewHistory.length - 1] = viewName; 
                }
            }

            // Garante que o player esteja escondido, exceto na view 'player'
            const videoPlayer = document.getElementById('video-player');
            if (viewName !== 'player') {
                videoPlayer.classList.add('hidden');
                document.body.classList.remove('overflow-hidden'); // Habilita scroll normal
                if (hls) {
                    hls.destroy();
                    hls = null;
                }
                videoPlayer.src = '';
                // Remove player controls
                const playerControls = document.getElementById('player-controls');
                if (playerControls) playerControls.remove();
                const lagIndicator = document.getElementById('lag-indicator');
                if (lagIndicator) lagIndicator.remove();
            } else {
                 // No player, garantimos fullscreen e zero padding/margin
                document.body.classList.add('overflow-hidden');
                videoPlayer.classList.remove('hidden');
            }

            // Renderiza a view e define o foco inicial
            switch (viewName) {
                case 'home':
                    renderHomePage(container);
                    break;
                case 'categories':
                    renderCategoriesPage(container);
                    break;
                case 'channels':
                    currentCategory = data;
                    renderChannelsPage(container, data);
                    break;
                case 'player':
                    currentChannelName = data.name;
                    initializeHlsPlayer(data.url);
                    break;
            }

            // Define o foco após a renderização
            focusedIndex = 0;
            updateFocus(0);
        }

        // -----------------------------------------------------------
        // 3. TELA INICIAL ('HOME')
        // -----------------------------------------------------------
        function renderHomePage(container) {
            const homeContent = `
                <div class="min-h-screen flex flex-col justify-center items-center relative bg-ipview-dark overflow-hidden">
                    <div class="bg-shapes absolute inset-0"></div> <div id="eye-logo" class="relative w-24 h-24 sm:w-32 sm:h-32 mb-6" style="filter: drop-shadow(0 0 10px rgba(109, 40, 217, 0.5));">
                        <svg viewBox="0 0 100 100" class="w-full h-full fill-current text-ipview-violet">
                            <path d="M50,10 C20,10 0,50 0,50 C0,50 20,90 50,90 C80,90 100,50 100,50 C100,50 80,10 50,10 Z" stroke="#9333EA" stroke-width="3" fill="none" class="eye-shape"></path>
                            <circle cx="50" cy="50" r="10" fill="url(#ipview-gradient)" id="pupil"></circle>
                            <defs>
                                <linearGradient id="ipview-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#6D28D9;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#9333EA;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                        </svg>
                        <style>
                            /* Animação do Glow (Pupila) */
                            @keyframes pupil-glow {
                                0%, 100% { box-shadow: 0 0 10px #6D28D9; }
                                50% { box-shadow: 0 0 25px #9333EA; }
                            }
                            #pupil {
                                animation: pupil-glow 3s infinite alternate;
                            }
                        </style>
                    </div>

                    <h1 class="ipview-gradient-text text-4xl sm:text-6xl font-black tracking-widest mb-16">IPVIEW</h1>

                    <button onclick="Maps('categories')" class="focusable
                        fixed left-1/2 -translate-x-1/2 bottom-8 z-20
                        lg:left-8 lg:bottom-auto lg:top-1/2 lg:-translate-y-1/2 lg:rotate-90 lg:w-auto
                        w-[90%] sm:w-2/3 max-w-lg
                        py-4 px-8 text-xl font-bold
                        rounded-[2rem] shadow-2xl
                        bg-white/5 backdrop-blur-md
                        border border-white/20
                        text-white hover:bg-white/10"
                        tabindex="0">
                        ASSISTIR TV AO VIVO
                    </button>

                    <footer class="fixed bottom-2 text-xs text-white/50 z-10">
                        Powered by Levi
                    </footer>
                </div>
            `;
            container.innerHTML = homeContent;
            setupEyeAnimations();
        }

        // 3. Animações JS/CSS para o Olho
        function setupEyeAnimations() {
            const eyeLogo = document.getElementById('eye-logo');
            const pupil = document.getElementById('pupil');

            // Micro-oscilação (Jitter/Translação Sutil)
            setInterval(() => {
                const tx = (Math.random() - 0.5) * 1.5;
                const ty = (Math.random() - 0.5) * 1.5;
                eyeLogo.style.transform = `translate(${tx}px, ${ty}px)`;
            }, 500);

            // Piscar (Fecha e Abre Suavemente)
            function blink() {
                eyeLogo.style.transition = 'opacity 0.2s';
                eyeLogo.style.opacity = '0.1'; // Fechar
                setTimeout(() => {
                    eyeLogo.style.opacity = '1'; // Abrir
                    const randomTime = Math.random() * (7000 - 4000) + 4000;
                    setTimeout(blink, randomTime);
                }, 200);
            }
            setTimeout(blink, 5000); // Inicia o primeiro piscar

            // Movimento da Pupila
            function movePupil() {
                const cx = 50 + (Math.random() - 0.5) * 8; // Sutil (max +/- 4)
                const cy = 50 + (Math.random() - 0.5) * 8;
                pupil.style.transition = 'cx 1s, cy 1s';
                pupil.setAttribute('cx', cx);
                pupil.setAttribute('cy', cy);
                const randomTime = Math.random() * (4000 - 1000) + 1000;
                setTimeout(movePupil, randomTime);
            }
            movePupil();
        }


        // -----------------------------------------------------------
        // 5. TELAS SECUNDÁRIAS ('CATEGORIES' e 'CHANNELS')
        // -----------------------------------------------------------

        // Renderiza a Tela de Categorias
        function renderCategoriesPage(container) {
            const categories = Object.keys(CHANNEL_DATA);
            const cards = categories.map((cat, index) => {
                const displayCat = cat.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                return `
                    <div onclick="Maps('channels', '${cat}')" class="focusable
                        bg-white/5 p-4 rounded-xl shadow-lg cursor-pointer
                        hover:bg-white/10 transition-colors duration-200
                        border border-transparent
                        flex justify-center items-center h-24"
                        tabindex="${index}">
                        <h2 class="text-xl font-bold text-center">${displayCat}</h2>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="p-8 min-h-screen">
                    <h1 class="text-3xl font-bold mb-8 ipview-gradient-text">Categorias</h1>
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-6">
                        ${cards}
                    </div>
                </div>
            `;
        }

        // Renderiza a Tela de Canais
        function renderChannelsPage(container, categoryKey) {
            const channels = CHANNEL_DATA[categoryKey] || [];
            const displayCat = categoryKey.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

            const cards = channels.map((channel, index) => {
                const isPlaceholder = channel.url.includes('placehold.co'); // Verifica se é um placeholder
                // Para Placeholders, usamos o link do placeholder como imagem (exemplo simples)
                const imageUrl = isPlaceholder ? channel.url : `https://placehold.co/400x225/250e41/ffffff?text=${channel.nome.replace(/\s/g, '+')}`;
                
                return `
                    <div onclick="Maps('player', ${JSON.stringify(channel).replace(/"/g, '&quot;')})" class="focusable
                        bg-white/5 rounded-xl shadow-lg cursor-pointer
                        hover:bg-white/10 transition-all duration-200
                        border border-transparent overflow-hidden"
                        tabindex="${index}">
                        <img src="${imageUrl}" alt="${channel.nome}" class="w-full h-auto object-cover aspect-video">
                        <div class="p-3">
                            <h3 class="text-lg font-semibold truncate">${channel.nome}</h3>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="p-8 min-h-screen">
                    <h1 class="text-3xl font-bold mb-8 ipview-gradient-text">${displayCat}</h1>
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
                        ${cards}
                    </div>
                </div>
            `;
        }


        // -----------------------------------------------------------
        // 6. PLAYER DE VÍDEO ('PLAYER') e HLS
        // -----------------------------------------------------------

        function initializeHlsPlayer(url) {
            const video = document.getElementById('video-player');
            const container = document.getElementById('app-container');

            // Adiciona controles ao DOM
            const controlsHtml = `
                <div id="player-controls" class="fixed top-0 left-0 w-full h-full pointer-events-none transition-opacity duration-500 opacity-100">
                    <div id="channel-info" class="absolute top-0 left-0 p-4 w-full bg-black/50 transition-opacity duration-500 opacity-100">
                        <h2 class="text-xl font-bold">${currentChannelName}</h2>
                    </div>
                    
                    <div id="lag-indicator" class="fixed top-4 right-4 p-2 rounded-full bg-red-600 text-white font-bold text-sm transition-opacity duration-300 opacity-0" style="pointer-events: all;">
                        ERRO/LAG
                    </div>
                </div>
            `;
            container.insertAdjacentHTML('afterend', controlsHtml); // Coloca após o app-container

            // Verifica se é um placeholder (não é stream HLS)
            if (url.includes('placehold.co')) {
                video.src = url;
                video.play().catch(e => console.error("Erro ao tentar reproduzir placeholder:", e));
                return;
            }

            // Destrói instância anterior, se existir
            if (hls) {
                hls.destroy();
            }

            // Inicializa HLS.js
            hls = new Hls({
                // Configurações avançadas
                abrBandwidthFactors: [0.8, 1.25],
                maxBufferLength: 30,
            });

            hls.loadSource(url);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                video.play().catch(e => console.error("Erro ao tentar reproduzir stream:", e));
            });

            const lagIndicator = document.getElementById('lag-indicator');
            const showIndicator = (message, isError) => {
                lagIndicator.textContent = message;
                lagIndicator.style.backgroundColor = isError ? 'rgb(220 38 38)' : 'rgb(234 88 12)'; // Red ou Orange
                lagIndicator.style.opacity = '100';
            };
            const hideIndicator = () => {
                lagIndicator.style.opacity = '0';
            };

            // Comportamento HLS: Indicador de Status
            hls.on(Hls.Events.ERROR, (event, data) => {
                if (data.fatal) {
                    showIndicator(`ERRO FATAL: ${data.details}`, true);
                } else {
                    showIndicator(`ERRO: ${data.details}`, true);
                }
            });

            hls.on(Hls.Events.BUFFER_EMPTY, () => showIndicator('BUFFER VAZIO (LAG)', false));
            hls.on(Hls.Events.BUFFER_STALLED, () => showIndicator('BUFFER PARADO (STALL)', false));
            hls.on(Hls.Events.BUFFER_FLUSHED, () => showIndicator('BUFFER REINICIADO', false));

            // Normalização: Oculta o indicador
            video.addEventListener('playing', hideIndicator);
            hls.on(Hls.Events.BUFFER_APPENDED, hideIndicator); // Indica que o buffer foi alimentado/estabilizado

            // Configura o Auto-Hide dos controles
            setupPlayerControls(video);
        }

        // 6. Controles (Auto-Hide)
        function setupPlayerControls(video) {
            const controls = document.getElementById('player-controls');
            const channelInfo = document.getElementById('channel-info');

            const autoHideControls = () => {
                clearTimeout(controlsTimer);
                channelInfo.style.opacity = '100'; // Mostrar
                controlsTimer = setTimeout(() => {
                    channelInfo.style.opacity = '0'; // Ocultar
                }, 5000); // 5 segundos
            };

            // Oculta ao carregar, mas exibe brevemente.
            autoHideControls();

            // Adiciona listener para interações que devem reativar o timer
            const showControls = () => {
                 // Alternar visibilidade na interação
                if (channelInfo.style.opacity === '100') {
                    // Se visível, oculta imediatamente
                    clearTimeout(controlsTimer);
                    channelInfo.style.opacity = '0';
                } else {
                    // Se oculto, mostra e inicia o timer
                    autoHideControls();
                }
            };
            
            // Adiciona a função ao objeto de foco (embora o Player não tenha foco ativo)
            video.showControls = showControls;

            // Se for um placeholder, permite pausar/tocar no clique
            if (video.src && video.src.includes('placehold.co')) {
                video.addEventListener('click', () => {
                    video.paused ? video.play() : video.pause();
                    showControls(); // Exibe info ao pausar/tocar
                });
            }
        }

        // -----------------------------------------------------------
        // 4. NAVEGAÇÃO E FOCO SMART TV
        // -----------------------------------------------------------

        // Adiciona/Remove a classe 'focused'
        function updateFocus(newIndex) {
            const focusables = Array.from(document.querySelectorAll('.focusable'));
            if (focusables.length === 0) return;

            // Remove foco do elemento anterior
            if (focusables[focusedIndex]) {
                focusables[focusedIndex].classList.remove('focused');
            }

            // Calcula o novo índice e garante que esteja dentro dos limites
            focusedIndex = Math.max(0, Math.min(newIndex, focusables.length - 1));

            // Adiciona foco ao novo elemento
            const newFocusElement = focusables[focusedIndex];
            if (newFocusElement) {
                newFocusElement.classList.add('focused');
                // Garante que o elemento focado esteja visível (bom para listas longas)
                newFocusElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Simula o clique no elemento focado
        function triggerClick() {
            const focusables = document.querySelectorAll('.focusable');
            if (focusables[focusedIndex]) {
                focusables[focusedIndex].click();
            }
        }

        // Lógica de Movimento do Foco (Simples - Baseado em Index)
        // Nota: Em uma interface de TV complexa, esta função usaria lógica matricial (coords x,y),
        // mas para cards em grid simples, o controle de index é suficiente.
        function findNextFocus(direction) {
            const focusables = document.querySelectorAll('.focusable');
            if (focusables.length === 0) return focusedIndex;

            // Para layout de cards, o cálculo simples por coluna é razoável.
            // Assumimos que em "Categories" e "Channels" há 4 colunas em telas médias/grandes
            let cols = 1;
            if (currentView === 'categories') {
                // Tailwind cols: 2 (default), 3 (md), 5 (lg)
                // Vamos usar 5 para a TV/Desktop (lg)
                cols = window.innerWidth >= 1024 ? 5 : window.innerWidth >= 768 ? 3 : 2;
            } else if (currentView === 'channels') {
                // Tailwind cols: 2 (default), 3 (md), 4 (lg), 5 (xl)
                // Vamos usar 4 para a TV/Desktop (lg)
                cols = window.innerWidth >= 1280 ? 5 : window.innerWidth >= 1024 ? 4 : window.innerWidth >= 768 ? 3 : 2;
            } else if (currentView === 'home') {
                 // Home tem apenas 1 elemento focado (o botão)
                 cols = 1;
            }


            let nextIndex = focusedIndex;
            switch (direction) {
                case 'ArrowUp':
                    nextIndex -= cols;
                    break;
                case 'ArrowDown':
                    nextIndex += cols;
                    break;
                case 'ArrowLeft':
                    nextIndex -= 1;
                    break;
                case 'ArrowRight':
                    nextIndex += 1;
                    break;
            }

            // Garante que o índice não saia dos limites
            return Math.max(0, Math.min(nextIndex, focusables.length - 1));
        }

        // 4. Eventos de Teclado
        function handleKeyDown(e) {
            const videoPlayer = document.getElementById('video-player');

            // Lógica do Player (Prioridade Máxima)
            if (currentView === 'player') {
                // 6. Voltar: Escape ou Backspace
                if (e.key === 'Escape' || e.key === 'Backspace') {
                    e.preventDefault();
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                    // Retorna para a lista de canais (assumindo que veio de lá)
                    Maps('channels', currentCategory);
                    return;
                }
                
                // 6. Interação (Enter/Espaço)
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    // Alterna visibilidade dos controles e reinicia o timer
                    videoPlayer.showControls();
                    return;
                }
            }
            
            // Lógica de Navegação por Foco (Para Telas Home, Categories, Channels)
            if (currentView !== 'player') {
                switch (e.key) {
                    case 'ArrowUp':
                    case 'ArrowDown':
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        e.preventDefault(); // Evita scroll da página
                        const nextIndex = findNextFocus(e.key);
                        updateFocus(nextIndex);
                        break;
                    case 'Enter':
                        e.preventDefault();
                        triggerClick(); // Simula clique no focado
                        break;
                    case 'Escape':
                    case 'Backspace':
                        e.preventDefault();
                        // 4. Retornar para a tela anterior
                        if (viewHistory.length > 1) {
                            viewHistory.pop(); // Remove a tela atual
                            const prevView = viewHistory.pop(); // Pega a tela anterior
                            // O Maps irá gerenciar o push de volta, por isso o pop duas vezes
                            
                            // Lógica para voltar com o contexto correto
                            if (prevView === 'channels') {
                                // Se voltar para canais, precisa da categoria anterior (não é totalmente rastreado)
                                // Para simplificar, assumimos que o Maps('channels') tem o contexto.
                                Maps('categories'); // Voltamos para categorias se não tiver certeza
                            } else {
                                Maps(prevView);
                            }
                        }
                        break;
                }
            }
        }

        // -----------------------------------------------------------
        // INICIALIZAÇÃO
        // -----------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            Maps('home'); // Inicia na tela inicial
        });

    </script>
</body>
</html>
