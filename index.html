<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPVIEW - Smart TV HLS Player</title>

    <!-- Fonte Inter (Google Fonts) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- HLS.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.11"></script>

    <!-- Configuração do Tailwind para usar a fonte Inter e cores customizadas -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'bg-main': '#0F071A',
                        'violet-1': '#6D28D9',
                        'violet-2': '#9333EA',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <!-- Estilos Customizados e Variáveis CSS -->
    <style>
        :root {
            --bg-main: #0F071A;
            --violet-1: #6D28D9;
            --violet-2: #9333EA;
            --color-focus-glow: 0 10px 30px rgba(147,51,234,0.45);
        }

        body {
            background-color: var(--bg-main);
            color: #E5E7EB; /* Cor do texto principal */
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Evita barras de rolagem */
            touch-action: pan-x pan-y; /* Melhora a experiência em touch */
        }
        
        /* Estilo para barras de rolagem customizadas (apenas estética) */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: rgba(147, 51, 234, 0.4);
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: var(--bg-main);
        }

        /* Estilo de Foco (Smart TV) para elementos .focusable */
        .focusable {
            outline: none;
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.25s ease, opacity 0.2s;
            will-change: transform, box-shadow;
        }

        .focused {
            transform: scale(1.06);
            box-shadow: var(--color-focus-glow);
            border-color: var(--violet-2);
            z-index: 10; /* Eleva o elemento focado */
        }

        /* Estilo para Botões Glassmorphism */
        .btn-glass {
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Estilo para o Indicador de Lag/Ping (Player) */
        .lag-indicator {
            transition: opacity 0.3s ease-in-out, background-color 0.3s;
            pointer-events: none;
            background-color: rgba(220, 38, 38, 0.9); /* Vermelho padrão (ERRO/LAG) */
        }

        /* Animações Abstratas de Fundo (Simulação cinematográfica) */
        @keyframes pulse-abstract {
            0%, 100% { transform: scale(1); opacity: 0.1; }
            50% { transform: scale(1.1); opacity: 0.25; }
        }

        .abstract-shape {
            animation: pulse-abstract 15s infinite ease-in-out;
            position: absolute;
            filter: blur(100px);
            opacity: 0.2;
            pointer-events: none;
        }
        
        /* Estilos e animações do Olho (Logo) */
        .eye-logo {
            filter: drop-shadow(0 0 10px var(--violet-2));
            transition: transform 0.1s ease;
        }

        /* Jitter/Micro-oscilação contínua (sutil) */
        @keyframes subtle-jitter {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(0.5px, -0.5px); }
            50% { transform: translate(-0.5px, 0.5px); }
            75% { transform: translate(0.5px, 0.5px); }
        }

        .eye-logo-group {
            animation: subtle-jitter 5s infinite alternate ease-in-out;
        }

        /* Animação do logo IPVIEW (gradiente de texto) */
        .ipview-text {
            background-image: linear-gradient(90deg, var(--violet-1), var(--violet-2));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            filter: drop-shadow(0 0 5px rgba(147, 51, 234, 0.7));
        }

        /* Ocultar a barra de controles nativa do vídeo */
        #video-player::-webkit-media-controls {
            display: none !important;
        }
        #video-player {
            pointer-events: none; /* Desativa interação por clique */
        }
    </style>
</head>
<body class="font-sans">

    <!-- Formas abstratas de fundo para efeito cinematográfico -->
    <div class="abstract-shape w-64 h-64 bg-violet-1 rounded-full top-1/4 left-1/4" style="animation-delay: 0s;"></div>
    <div class="abstract-shape w-96 h-96 bg-violet-2 rounded-full bottom-1/3 right-1/4" style="animation-delay: -7s;"></div>

    <!-- Container principal da aplicação -->
    <div id="app" class="relative w-screen h-screen">
        <div id="app-content" class="w-full h-full relative z-10">
            <!-- Conteúdo da view será renderizado aqui -->
        </div>

        <!-- O rodapé 'Powered by Levi' foi movido para a renderHomePage() -->
    </div>

    <!-- Vídeo Player (sempre presente para HLS) -->
    <video id="video-player" class="fixed top-0 left-0 w-full h-full object-cover z-0" playsinline></video>

    <!-- Overlay do Player para Controles (Nome do Canal e Lag) -->
    <div id="player-overlay" class="fixed top-0 left-0 w-full h-full flex flex-col justify-between p-6 opacity-0 transition-opacity duration-300 pointer-events-none z-30 bg-black/10">
        <!-- Indicador de Lag/Erro/Ping (no canto superior direito) -->
        <div id="lag-indicator" class="lag-indicator ml-auto text-white px-3 py-1 rounded-full text-sm font-bold opacity-0 shadow-lg flex items-center" role="status" aria-live="polite">
            <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 1 0 00-2 0v5a1 1 0 102 0v-5zm3-3a1 1 0 00-2 0v8a1 1 0 102 0V7z" clip-rule="evenodd"></path></svg>
            <span id="lag-text">LAG / ERRO</span>
            <span id="ping-value" class="ml-2 font-mono"></span>
        </div>
        
        <!-- Barra de Informações do Canal (Inferior) -->
        <div id="channel-info" class="self-start">
            <h1 id="channel-name" class="text-3xl lg:text-5xl font-extrabold text-white"></h1>
            <p id="channel-category" class="text-lg lg:text-xl text-gray-300 opacity-75"></p>
        </div>
    </div>
    
    <!-- Overlay de Carregamento Minimalista (aparece ao entrar no player) -->
    <div id="loading-overlay" class="fixed inset-0 bg-bg-main flex items-center justify-center opacity-0 transition-opacity duration-300 pointer-events-none z-40">
        <div id="loading-content" class="flex flex-col items-center">
            <!-- Logo e texto injetados via JS -->
        </div>
    </div>


<script>
    // ----------------------------------------------------------------------
    // 1. DADOS E ESTADO GLOBAL
    // ----------------------------------------------------------------------
    const CHANNEL_DATA = {
        "esportes": [
            { "nome": "Premiere 1", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/d485d118d525ae4326aa31371f5dfcef/premiere.m3u8" },
            { "nome": "Premiere 2", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/aa1f6257eeb308e3e6677bae5fb7f1c8/premiere2.m3u8" }
        ],
        "noticias": [
            { "nome": "Record News", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/3728ae10c1a4f5b4a394d9771ec12db2/record.m3u8" }
        ],
        "infantil": [
            { "nome": "Cartoon Network", "url": "https://d1muf25xa11so8hp22.s27-usa-cloudfront-net.online/token/f67e159151a581847c31a461034c795a/cartoonnetwork.m3u8" },
            { "nome": "Nickelodeon", "url": "https://d1muf25xa11so8e1847c31a461034c795a/nickelodeon.m3u8" }
        ],
        "filmes_e_series": [
            { "nome": "Telecine Premium", "url": "https://placehold.co/400x225/ba55d3/ffffff?text=Telecine" },
            { "nome": "HBO HD", "url": "https://placehold.co/400x225/4b0082/ffffff?text=HBO" }
        ],
        "variedades": [
            { "nome": "Multishow", "url": "https://placehold.co/400x225/daa520/000000?text=Multi" },
            { "nome": "GNT", "url": "https://placehold.co/400x225/808080/ffffff?text=GNT" }
        ]
    };
    
    // Mapeamento de chaves para nomes legíveis
    const CATEGORY_NAMES = {
        "esportes": "Esportes",
        "noticias": "Notícias",
        "infantil": "Infantil",
        "filmes_e_series": "Filmes e Séries",
        "variedades": "Variedades"
    };

    let currentView = 'home';
    let historyStack = [];
    let focusedElement = null;
    let controlsTimeout = null;
    let currentChannel = null; // Armazena o objeto do canal atualmente em reprodução
    let hls = null;
    let lastRenderData = null; // Armazena o 'data' usado para renderizar a view atual (ex: categoryKey)

    // Referências DOM
    const appContent = document.getElementById('app-content');
    const videoPlayer = document.getElementById('video-player');
    const playerOverlay = document.getElementById('player-overlay');
    const lagIndicator = document.getElementById('lag-indicator');
    const lagText = document.getElementById('lag-text');
    const pingValueDisplay = document.getElementById('ping-value');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingContent = document.getElementById('loading-content');
    const channelNameDisplay = document.getElementById('channel-name');
    const channelCategoryDisplay = document.getElementById('channel-category');

    // ----------------------------------------------------------------------
    // 2. UTILITÁRIOS E FOCO
    // ----------------------------------------------------------------------

    /**
     * Define o elemento focado (UI do Smart TV).
     * @param {HTMLElement} element 
     */
    function setFocus(element) {
        if (focusedElement) {
            focusedElement.classList.remove('focused');
        }
        if (element && element.classList.contains('focusable')) {
            focusedElement = element;
            focusedElement.classList.add('focused');
            focusedElement.focus();
            
            // Garante que o elemento focado esteja visível (scroll se necessário)
            focusedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else {
            focusedElement = null;
        }
    }

    /**
     * Retorna o BoundingClientRect de um elemento.
     * @param {HTMLElement} element 
     * @returns {DOMRect}
     */
    const getRect = (element) => element.getBoundingClientRect();

    /**
     * Algoritmo espacial para encontrar o próximo elemento focusable na direção dada.
     * (Mantido o algoritmo original, focado na distância e sobreposição)
     * @param {string} direction 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
     */
    function findNextFocus(direction) {
        if (!focusedElement) return;

        const focusables = Array.from(document.querySelectorAll('.focusable:not([hidden])'));
        if (focusables.length <= 1) return;

        const currentRect = getRect(focusedElement);
        let bestCandidate = null;
        let minDistance = Infinity;

        focusables.forEach(candidate => {
            if (candidate === focusedElement) return;

            const candidateRect = getRect(candidate);
            let isCandidateInDirection = false;
            let distance = Infinity;

            // 1. Verifica se o candidato está na direção correta
            if (direction === 'ArrowUp' && candidateRect.bottom <= currentRect.top) {
                isCandidateInDirection = true;
                distance = currentRect.top - candidateRect.bottom + Math.abs((currentRect.left + currentRect.right) / 2 - (candidateRect.left + candidateRect.right) / 2);
            } else if (direction === 'ArrowDown' && candidateRect.top >= currentRect.bottom) {
                isCandidateInDirection = true;
                distance = candidateRect.top - currentRect.bottom + Math.abs((currentRect.left + currentRect.right) / 2 - (candidateRect.left + candidateRect.right) / 2);
            } else if (direction === 'ArrowLeft' && candidateRect.right <= currentRect.left) {
                isCandidateInDirection = true;
                distance = currentRect.left - candidateRect.right + Math.abs((currentRect.top + currentRect.bottom) / 2 - (candidateRect.top + candidateRect.bottom) / 2);
            } else if (direction === 'ArrowRight' && candidateRect.left >= currentRect.right) {
                isCandidateInDirection = true;
                distance = candidateRect.left - currentRect.right + Math.abs((currentRect.top + currentRect.bottom) / 2 - (candidateRect.top + currentRect.bottom) / 2);
            }

            // 2. Trata sobreposição ou proximidade em layouts de grid/mobile
            if (!isCandidateInDirection) {
                const horizontalOverlap = Math.max(0, Math.min(currentRect.right, candidateRect.right) - Math.max(currentRect.left, candidateRect.left));
                const verticalOverlap = Math.max(0, Math.min(currentRect.bottom, candidateRect.bottom) - Math.max(currentRect.top, currentRect.top));

                if (direction === 'ArrowUp' && currentRect.top > candidateRect.top && horizontalOverlap > 0) {
                    distance = (currentRect.top - candidateRect.top) / horizontalOverlap; 
                    isCandidateInDirection = true;
                } else if (direction === 'ArrowDown' && currentRect.bottom < candidateRect.bottom && horizontalOverlap > 0) {
                    distance = (candidateRect.top - currentRect.top) / horizontalOverlap; 
                    isCandidateInDirection = true;
                } else if (direction === 'ArrowLeft' && currentRect.left > candidateRect.left && verticalOverlap > 0) {
                    distance = (currentRect.left - candidateRect.left) / verticalOverlap; 
                    isCandidateInDirection = true;
                } else if (direction === 'ArrowRight' && currentRect.right < candidateRect.right && verticalOverlap > 0) {
                    distance = (candidateRect.right - currentRect.right) / verticalOverlap; 
                    isCandidateInDirection = true;
                }
            }


            if (isCandidateInDirection && distance < minDistance) {
                minDistance = distance;
                bestCandidate = candidate;
            }
        });

        if (bestCandidate) {
            setFocus(bestCandidate);
        }
    }

    // ----------------------------------------------------------------------
    // 3. ANIMAÇÃO DO OLHO (LOGO)
    // ----------------------------------------------------------------------

    /**
     * Cria e retorna o SVG do logo Olho IPVIEW (Design mais técnico/detalhado).
     */
    function createEyeLogo() {
        return `
            <svg class="eye-logo-group w-32 h-32 md:w-48 md:h-48" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Olho Externo (Borda tripla) -->
                <circle id="eye-outer-a" cx="50" cy="50" r="45" fill="none" stroke="url(#violet-grad)" stroke-width="1.5" />
                <circle id="eye-outer-b" cx="50" cy="50" r="48" fill="none" stroke="url(#violet-grad)" stroke-width="0.5" opacity="0.5" />
                
                <!-- Íris (Anel) -->
                <circle id="eye-iris" cx="50" cy="50" r="20" fill="none" stroke="url(#violet-grad)" stroke-width="1" />
                
                <!-- Pupila (Hexagonal/Geométrica) -->
                <path id="eye-pupil" d="M 50 40 L 55 45 L 55 55 L 50 60 L 45 55 L 45 45 Z" fill="url(#violet-grad)" style="transform-origin: center center; transform: scale(1.2);"/>

                <!-- Delineado da Pálpebra (usado para o efeito de piscar) -->
                <path id="eyelid-path" d="M 10 50 C 30 20, 70 20, 90 50" stroke="url(#violet-grad)" stroke-width="4" fill="var(--bg-main)" style="transform-origin: center center; transition: transform 0.5s ease;" />
                
                <!-- Linhas de escaneamento (adiciona detalhe futurista) -->
                <path d="M 10 50 L 90 50" stroke="var(--violet-2)" stroke-width="0.3" opacity="0.5" stroke-dasharray="5, 5" />
                
                <!-- Gradiente para o Glow -->
                <defs>
                    <linearGradient id="violet-grad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:var(--violet-1); stop-opacity:1" />
                        <stop offset="100%" style="stop-color:var(--violet-2); stop-opacity:1" />
                    </linearGradient>
                </defs>
            </svg>
        `;
    }

    /**
     * Inicia as animações JS do logo (piscar e movimento da pupila).
     */
    function startEyeAnimations() {
        const pupil = document.getElementById('eye-pupil');
        const eyelid = document.getElementById('eyelid-path');
        if (!pupil || !eyelid) return;

        // 1. Animação de Piscar
        const blink = () => {
            // Fecha o olho
            eyelid.style.transform = 'scaleY(0)'; 
            setTimeout(() => {
                // Abre o olho
                eyelid.style.transform = 'scaleY(1)';
                // Agenda o próximo piscar com intervalo randomizado (4-7s)
                const nextBlink = Math.random() * 3000 + 4000;
                setTimeout(blink, nextBlink);
            }, 500); // Duração do fechamento/abertura
        };
        setTimeout(blink, 5000); // Inicia o primeiro piscar

        // 2. Movimento da Pupila (ajustado para Path/Polygon)
        const movePupil = () => {
            // Movimenta o pupil Path/Polygon sutilmente
            const tx = (Math.random() - 0.5) * 3; // Deslocamento sutil (-1.5 a +1.5)
            const ty = (Math.random() - 0.5) * 3; 
            pupil.style.transform = `translate(${tx}px, ${ty}px) scale(1.2)`;

            // Agenda o próximo movimento com intervalo irregular (1-3s)
            const nextMove = Math.random() * 2000 + 1000;
            setTimeout(movePupil, nextMove);
        };
        setTimeout(movePupil, 1000); // Inicia o movimento
    }

    // ----------------------------------------------------------------------
    // 4. FUNÇÕES DE RENDERIZAÇÃO DE VIEWS
    // ----------------------------------------------------------------------

    /**
     * Renderiza a tela inicial (Home).
     */
    function renderHomePage() {
        appContent.innerHTML = `
            <div class="h-full flex flex-col items-center justify-center p-4">
                <div class="flex flex-col items-center mb-16">
                    ${createEyeLogo()}
                    <h1 class="ipview-text text-5xl md:text-7xl font-extrabold tracking-widest mt-4 uppercase">
                        IPVIEW
                    </h1>
                </div>

                <!-- Botão centralizado para desktop e flutuante para mobile (Responsividade) -->
                <button id="btn-watch" 
                        class="focusable btn-glass text-xl font-bold rounded-full px-8 py-4 shadow-xl hover:shadow-2xl active:scale-95 transition duration-200 
                               w-[calc(100%-4rem)] max-w-sm md:w-auto md:h-auto 
                               absolute md:static bottom-8"
                        tabindex="0" role="button" aria-label="Acessar categorias de canais">
                    ASSISTIR TV AO VIVO
                </button>
                
                <!-- Rodapé (Apenas na Home) -->
                <footer class="absolute bottom-2 w-full text-center text-xs opacity-50 z-20 pointer-events-none">
                    Powered by Levi
                </footer>
            </div>
        `;
        // Inicia as animações após o SVG ser injetado no DOM
        startEyeAnimations();
        return document.getElementById('btn-watch');
    }

    /**
     * Renderiza a tela de Categorias.
     */
    function renderCategoriesPage() {
        const categoriesHtml = Object.keys(CHANNEL_DATA).map(key => `
            <button class="focusable btn-glass w-full h-32 md:h-48 flex items-center justify-center text-xl md:text-2xl font-semibold rounded-2xl shadow-lg hover:shadow-xl active:scale-95"
                    data-category="${key}" tabindex="0" role="listitem" aria-label="Abrir categoria ${CATEGORY_NAMES[key]}">
                ${CATEGORY_NAMES[key]}
            </button>
        `).join('');

        appContent.innerHTML = `
            <div class="p-8 h-full overflow-y-auto custom-scrollbar">
                <h2 class="text-4xl font-bold mb-8 text-white/90">Categorias</h2>
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
                    ${categoriesHtml}
                </div>
            </div>
        `;
        // Retorna o primeiro botão para foco inicial
        return document.querySelector('.focusable');
    }

    /**
     * Renderiza a tela de Canais para uma categoria.
     * @param {string} categoryKey
     */
    function renderChannelsPage(categoryKey) {
        const channels = CHANNEL_DATA[categoryKey] || [];
        const categoryName = CATEGORY_NAMES[categoryKey] || 'Categoria Desconhecida';
        
        const channelsHtml = channels.map(channel => {
            const isPlaceholder = channel.url.includes('placehold.co');
            const posterUrl = isPlaceholder ? channel.url.split('?')[0] : 'https://placehold.co/400x225/111827/ffffff?text=' + encodeURIComponent(channel.nome);

            return `
                <button class="focusable group w-full aspect-video flex flex-col rounded-xl overflow-hidden shadow-xl active:scale-[1.03] transition duration-200"
                        data-channel-name="${channel.nome}" data-channel-url="${channel.url}" data-channel-category="${categoryName}" data-category-key="${categoryKey}" 
                        tabindex="0" role="listitem" aria-label="Abrir canal ${channel.nome}">
                    <div class="h-full bg-cover bg-center flex items-end justify-start p-3 bg-gray-800" 
                         style="background-image: url('${posterUrl}');">
                        <span class="bg-black/70 px-2 py-1 rounded-md text-sm font-semibold text-white group-hover:bg-violet-2/90 transition">
                            ${channel.nome}
                        </span>
                    </div>
                </button>
            `;
        }).join('');

        appContent.innerHTML = `
            <div class="p-8 h-full overflow-y-auto custom-scrollbar">
                <h2 class="text-4xl font-bold mb-8 text-white/90">← ${categoryName}</h2>
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
                    ${channelsHtml}
                </div>
            </div>
        `;
        // Retorna o primeiro canal para foco inicial
        return document.querySelector('.focusable');
    }

    /**
     * Mostra o overlay de carregamento.
     */
    function showLoadingOverlay() {
        loadingContent.innerHTML = `
            <div class="flex flex-col items-center">
                ${createEyeLogo()}
                <div class="text-white mt-4 text-lg font-semibold tracking-wider animate-pulse">CARREGANDO...</div>
            </div>
        `;
        loadingOverlay.style.opacity = '1';
        loadingOverlay.style.pointerEvents = 'auto';
        startEyeAnimations();
    }

    /**
     * Esconde o overlay de carregamento.
     */
    function hideLoadingOverlay() {
        loadingOverlay.style.opacity = '0';
        loadingOverlay.style.pointerEvents = 'none';
    }


    /**
     * Renderiza a tela do Player (Full Viewport).
     * @param {object} channelObj - { nome, url, category, categoryKey }
     */
    function renderPlayerView(channelObj) {
        // 1. Inicia Carregamento Minimalista
        showLoadingOverlay(); 

        // 2. Oculta o conteúdo da aplicação e prepara player
        appContent.style.display = 'none';
        playerOverlay.style.zIndex = '30';
        videoPlayer.style.zIndex = '1';
        
        channelNameDisplay.textContent = channelObj.nome;
        channelCategoryDisplay.textContent = channelObj.category;
        currentChannel = channelObj; // Atualiza o canal atual

        // 3. Inicializa o Player
        initializeHlsPlayer(channelObj.url);

        // 4. Exibe controles iniciais por 7s (se não houver erro)
        setAutoHideControls(7000);

        return null; 
    }

    /**
     * Limpa a view do player e retorna à lista de canais.
     */
    function exitPlayerView() {
        if (hls) {
            hls.destroy();
            hls = null;
        }
        videoPlayer.src = '';
        videoPlayer.removeAttribute('poster');
        
        // Garante que o loading está escondido
        hideLoadingOverlay(); 

        appContent.style.display = 'block';
        playerOverlay.style.zIndex = '-1';
        playerOverlay.style.opacity = '0';
        videoPlayer.style.zIndex = '0';
        lagIndicator.style.opacity = '0';

        // Volta para a view anterior
        Maps('back');
    }

    // ----------------------------------------------------------------------
    // 5. PLAYER HLS E CONTROLES
    // ----------------------------------------------------------------------

    /**
     * Simulação do Ping (0-9999ms).
     * @returns {number}
     */
    function simulatePing() {
        // Simula um ping razoável (50-150ms) ou alto (1000-9999ms) se estiver em estado de erro
        if (lagIndicator.style.opacity === '1' && lagText.textContent !== 'OK') {
            // Ping alto/lag
            return Math.floor(Math.random() * (9999 - 1000 + 1)) + 1000;
        } else {
            // Ping normal
            return Math.floor(Math.random() * (150 - 50 + 1)) + 50;
        }
    }
        
    /**
     * Atualiza o indicador de Lag/Ping.
     * @param {boolean} isVisible - Se o indicador deve estar visível.
     * @param {string} text - O texto de status (ex: OK, LAG, ERRO).
     * @param {boolean} isError - Se o status é de erro/lag (muda a cor de fundo).
     */
    function updateLagIndicator(isVisible, text, isError = false) {
        lagText.textContent = text;
        pingValueDisplay.textContent = isVisible ? `${simulatePing()}ms` : '';
        // Verde (OK) ou Vermelho (Erro/Lag)
        lagIndicator.style.backgroundColor = isError ? 'rgba(220, 38, 38, 0.9)' : 'rgba(20, 150, 20, 0.9)'; 
        lagIndicator.style.opacity = isVisible ? '1' : '0';
    }

    /**
     * Gerencia a visibilidade da barra de controles e lag indicator.
     * @param {number} timeoutMs - Tempo em milissegundos para auto-hide.
     */
    function setAutoHideControls(timeoutMs = 5000) {
        // Limpa o timer anterior
        clearTimeout(controlsTimeout);
        
        // Mostra o overlay
        playerOverlay.style.opacity = '1';

        // Agenda o auto-hide
        controlsTimeout = setTimeout(() => {
            playerOverlay.style.opacity = '0';
        }, timeoutMs);
    }

    /**
     * Inicializa o HLS.js para carregar o stream no player.
     * @param {string} url - URL do stream M3U8.
     */
    function initializeHlsPlayer(url) {
        if (hls) {
            hls.destroy();
            hls = null;
        }

        updateLagIndicator(true, "CARREGANDO", true); // Status inicial

        // Verifica se a URL é um placeholder e usa como poster/fallback
        if (url.includes('placehold.co')) {
            videoPlayer.poster = url.split('?')[0];
            updateLagIndicator(true, "CONTEÚDO PLACEHOLDER", false);
            lagIndicator.style.backgroundColor = 'rgba(109, 40, 217, 0.9)'; // Violeta
            videoPlayer.style.display = 'none';
            hideLoadingOverlay();
            return;
        } else {
            videoPlayer.poster = '';
            videoPlayer.style.display = 'block';
        }

        // 1. Suporte Nativo (Safari, etc.)
        if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
            videoPlayer.src = url;
            videoPlayer.addEventListener('loadedmetadata', () => {
                 videoPlayer.play();
                 hideLoadingOverlay();
                 updateLagIndicator(false, "OK", false);
            });
            videoPlayer.play().catch(e => console.warn('Autoplay bloqueado (native)', e));
            return;
        }

        // 2. HLS.js
        if (Hls.isSupported()) {
            hls = new Hls({
                liveSyncDurationCount: 3, 
            });
            hls.loadSource(url);
            hls.attachMedia(videoPlayer);

            hls.on(Hls.Events.MANIFEST_PARSED, () => {
                videoPlayer.play().catch(e => {
                    console.warn('Autoplay bloqueado (hls.js). Usuário deve interagir.', e);
                });
            });

            // Gerenciamento de eventos de buffer e erro
            hls.on(Hls.Events.ERROR, (event, data) => {
                console.error('HLS Error:', data);
                if (data.fatal) {
                    updateLagIndicator(true, "ERRO FATAL (Recarregar)", true);
                    hls.destroy();
                } else if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                    updateLagIndicator(true, "ERRO DE REDE", true);
                }
            });

            hls.on(Hls.Events.BUFFER_EMPTY, () => {
                updateLagIndicator(true, "RECARREGANDO", true);
            });
            hls.on(Hls.Events.BUFFER_STALLED, () => {
                updateLagIndicator(true, "LAG", true);
            });

            // Oculta o indicador de lag quando a reprodução começa/continua
            videoPlayer.addEventListener('playing', () => {
                updateLagIndicator(false, "OK", false);
                hideLoadingOverlay(); // Esconde o loading ao iniciar a reprodução
            });
            videoPlayer.addEventListener('waiting', () => {
                updateLagIndicator(true, "CARREGANDO", true);
            });

        } else {
            // Fallback
            appContent.innerHTML = `<div class="p-10 text-center text-xl text-red-400">Seu navegador não suporta streaming HLS.</div>`;
            videoPlayer.style.display = 'none';
            hideLoadingOverlay();
        }
    }

    // ----------------------------------------------------------------------
    // 6. NAVEGAÇÃO CENTRAL E CONTROLE DE TECLADO
    // ----------------------------------------------------------------------

    /**
     * Função central de navegação entre views.
     * @param {string} viewName - Nome da view ('home', 'categories', 'channels', 'player', 'back').
     * @param {any} data - Dados opcionais. Para 'channels', é a categoryKey. Para 'player', é o channelObj.
     */
    function Maps(viewName, data = null) {
        let nextFocusElement = null;

        if (viewName === 'back') {
            const previous = historyStack.pop();
            if (previous) {
                viewName = previous.viewName;
                data = previous.data; // categoryKey ou null
            } else {
                viewName = 'home'; // Se não houver histórico, volta para home
                data = null;
            }
        } else if (viewName !== currentView) {
            // Salva o estado atual ANTES de mudar. Usa lastRenderData para o contexto
            historyStack.push({ viewName: currentView, data: lastRenderData });
        }
        
        // Limpa o foco anterior e o conteúdo, prepara para a nova view
        setFocus(null);
        appContent.innerHTML = '';
        currentView = viewName;
        appContent.style.display = 'block';
        playerOverlay.style.zIndex = '-1';
        playerOverlay.style.opacity = '0'; // Garante que o overlay do player não está visível
        videoPlayer.style.zIndex = '0';
        lagIndicator.style.opacity = '0';
        hideLoadingOverlay(); // Garante que o loading está escondido ao mudar de view
        
        // Define o lastRenderData para o contexto atual
        let renderData = data;

        switch (viewName) {
            case 'home':
                nextFocusElement = renderHomePage();
                lastRenderData = null;
                break;
            case 'categories':
                nextFocusElement = renderCategoriesPage();
                lastRenderData = null;
                break;
            case 'channels':
                // O data deve ser a categoryKey
                if (!renderData || !CHANNEL_DATA[renderData]) {
                    console.error("Erro de navegação: categoryKey inválida, voltando para categorias.", data);
                    Maps('categories');
                    return;
                }
                nextFocusElement = renderChannelsPage(renderData);
                lastRenderData = renderData; // Salva o categoryKey
                break;
            case 'player':
                nextFocusElement = renderPlayerView(renderData);
                lastRenderData = renderData; // Salva o channelObj
                break;
            default:
                nextFocusElement = renderHomePage();
                lastRenderData = null;
        }

        // Define o foco inicial na nova view, se houver elementos focáveis
        if (nextFocusElement) {
            setFocus(nextFocusElement);
        } else if (document.querySelector('.focusable')) {
             setFocus(document.querySelector('.focusable'));
        }
    }

    /**
     * Gerenciador principal de eventos de teclado (simulação de controle remoto).
     * @param {KeyboardEvent} e 
     */
    function handleKeyDown(e) {
        // Ignora eventos que não são de teclas de controle
        if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', 'Space', 'Escape', 'Backspace'].includes(e.key)) {
            return;
        }

        e.preventDefault(); // Impede o scroll da página, etc.

        if (currentView === 'player') {
            // Lógica para Troca de Canais no Player (Seta Cima/Baixo)
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                const categoryKey = currentChannel?.categoryKey;
                const channelList = CHANNEL_DATA[categoryKey];
                
                if (!channelList || channelList.length < 2) return; // Não há canais suficientes para trocar

                const currentIndex = channelList.findIndex(c => c.nome === currentChannel.nome);
                if (currentIndex === -1) return; // Canal atual não encontrado na lista (erro)

                let newIndex = currentIndex;
                const totalChannels = channelList.length;

                if (e.key === 'ArrowDown') {
                    // Próximo canal (com wrap-around)
                    newIndex = (currentIndex + 1) % totalChannels;
                } else if (e.key === 'ArrowUp') {
                    // Canal anterior (com wrap-around, garantindo índice não-negativo)
                    newIndex = (currentIndex - 1 + totalChannels) % totalChannels;
                }

                if (newIndex !== currentIndex) {
                    const newChannel = channelList[newIndex];
                    
                    // Prepara o novo objeto de canal
                    const newChannelObj = {
                        nome: newChannel.nome,
                        url: newChannel.url,
                        category: CATEGORY_NAMES[categoryKey],
                        categoryKey: categoryKey
                    };

                    // Carrega e renderiza o novo canal (destruindo o anterior automaticamente)
                    renderPlayerView(newChannelObj);
                    
                    // Exibe brevemente os controles para mostrar a troca de canal
                    setAutoHideControls(4000); 
                }
                
            } else if (e.key === 'Enter' || e.key === ' ') {
                // Enter/Space: Alterna visibilidade dos controles
                if (playerOverlay.style.opacity === '1') {
                    setAutoHideControls(0); // Oculta imediatamente (timeout 0)
                } else {
                    setAutoHideControls(7000); // Mostra e agenda auto-hide
                }
            } else if (e.key === 'Escape' || e.key === 'Backspace') {
                // Escape/Backspace: Sai do player
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                exitPlayerView();
            }
            return; // Nenhuma navegação de foco no player
        }

        // Lógica de navegação de foco para Home, Categories, Channels
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            findNextFocus(e.key);
        } else if (e.key === 'Enter') {
            if (focusedElement) {
                // Simula o clique/ativação do elemento focado
                const categoryKey = focusedElement.getAttribute('data-category');
                const channelName = focusedElement.getAttribute('data-channel-name');
                const channelUrl = focusedElement.getAttribute('data-channel-url');
                const channelCategory = focusedElement.getAttribute('data-channel-category');
                const channelCategoryKey = focusedElement.getAttribute('data-category-key'); // Pega o key da lista de canais

                if (categoryKey) {
                    // Abrir lista de canais (Categories -> Channels)
                    Maps('channels', categoryKey);
                } else if (channelUrl) {
                    // Abrir player (Channels -> Player)
                    Maps('player', { 
                        nome: channelName, 
                        url: channelUrl, 
                        category: channelCategory, 
                        categoryKey: channelCategoryKey // Passa a chave da categoria para o player
                    });
                } else if (focusedElement.id === 'btn-watch') {
                    // Botão 'ASSISTIR TV AO VIVO' (Home -> Categories)
                    Maps('categories');
                } else {
                    // Caso geral: simula clique
                    focusedElement.click(); 
                }
            }
        } else if (e.key === ' ') {
             // Space age como Enter se não estiver no Player
             if(focusedElement) {
                 focusedElement.click();
             }
        } else if (e.key === 'Escape' || e.key === 'Backspace') {
            // Escape/Backspace: Voltar para a view anterior
            Maps('back');
        }
    }


    // ----------------------------------------------------------------------
    // 7. INICIALIZAÇÃO
    // ----------------------------------------------------------------------
    window.onload = () => {
        // 1. Adiciona listener de teclado global
        window.addEventListener('keydown', handleKeyDown);

        // 2. Adiciona listener de clique/toque para elementos focáveis (para desktop/mobile)
        appContent.addEventListener('click', (e) => {
            let target = e.target.closest('.focusable');
            if (target) {
                // Redireciona o clique para a lógica de Enter/Ativação
                setFocus(target); 
                handleKeyDown({ key: 'Enter', preventDefault: () => {} });
            }
        });

        // 3. Inicia a aplicação na Home Page
        Maps('home');
    };
</script>

</body>
</html>
